/*
Cuckoo Sandbox - Automated Malware Analysis.
Copyright (C) 2016 Cuckoo Foundation.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <stdint.h>
#include <windows.h>
#include "memory.h"
#include "misc.h"
#include "native.h"
#include "pipe.h"

static array_t g_last_guard_page_addr_array;

void exploit_init()
{
    LDR_MODULE *mod; PEB *peb = get_peb();

    array_init(&g_last_guard_page_addr_array);

    for (mod = (LDR_MODULE *) peb->LoaderData->InLoadOrderModuleList.Flink;
         mod->BaseAddress != NULL;
         mod = (LDR_MODULE *) mod->InLoadOrderModuleList.Flink) {

        exploit_set_guard_page(mod->BaseAddress, 0x1000);
    }
}

int exploit_set_guard_page(void *addr, uint32_t length)
{
    MEMORY_BASIC_INFORMATION_CROSS mbi;

    if(virtual_query(addr, &mbi) == FALSE ||
            (mbi.Protect & PAGE_READABLE) == 0) {
        return -1;
    }

    if(NT_SUCCESS(virtual_protect(
            addr, length, mbi.Protect | PAGE_GUARD)) == FALSE) {
        return -1;
    }
    return 0;
}

void *exploit_get_last_guard_page()
{
    void *ret = array_get(
        &g_last_guard_page_addr_array, get_current_thread_id()
    );
    array_set(
        &g_last_guard_page_addr_array, get_current_thread_id(), NULL
    );
    return ret;
}

void exploit_set_last_guard_page(void *addr)
{
    array_set(
        &g_last_guard_page_addr_array, get_current_thread_id(), addr
    );
}

static int addr_in_stack(void *addr)
{
    NT_TIB *tib = (NT_TIB *) readtls(TLS_TEB);
    return addr >= tib->StackLimit && addr < tib->StackBase;
}

// Currently we just check if the memory block is of MEM_PRIVATE type.
// There are some APIs for traversing the heap, but they might miss
// some of the heap blocks (e.g., regions allocated through VirtualAlloc).
static int addr_in_heap(void *addr)
{
    MEMORY_BASIC_INFORMATION_CROSS mbi;
    virtual_query(addr, &mbi);
    return mbi.Type == MEM_PRIVATE;
}

int exploit_is_stack_pivoted()
{
    void *ptr = NULL;
    return addr_in_stack(&ptr) == 0;
}

int exploit_makes_stack_executable(
    HANDLE process_handle, PVOID addr, DWORD new_protection)
{
    return (new_protection & PAGE_EXECUTABLE) != 0 &&
        addr_in_stack(addr) != FALSE &&
        process_handle == get_current_process();
}

int exploit_makes_heap_executable(
    HANDLE process_handle, PVOID addr, DWORD new_protection)
{
    return (new_protection & PAGE_EXECUTABLE) != 0 &&
        addr_in_heap(addr) != FALSE &&
        process_handle == get_current_process();
}

int exploit_is_guard_page_refer_whitelisted(uintptr_t *addrs, uint32_t count)
{
    (void) addrs; (void) count;
    return -1;
}
