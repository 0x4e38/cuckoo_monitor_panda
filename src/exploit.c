/*
Cuckoo Sandbox - Automated Malware Analysis.
Copyright (C) 2016 Cuckoo Foundation.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <stdint.h>
#include <windows.h>
#include "hooking.h"
#include "memory.h"
#include "misc.h"
#include "log.h"
#include "native.h"
#include "pipe.h"

static array_t g_last_guard_page_addr_array;
static slab_t g_guard_page_referer_slab;
static uintptr_t g_guard_pages[32];
static uint32_t g_guard_page_count;

void find_guard_page_whitelist(uintptr_t *addresses, uint32_t *count);

void exploit_init()
{
    LDR_MODULE *mod; PEB *peb = get_peb();

    array_init(&g_last_guard_page_addr_array);
    slab_init(
        &g_guard_page_referer_slab, sizeof(hook_t), 128,
        PAGE_EXECUTE_READWRITE
    );

#if __x86_64__
    return;
#endif

    find_guard_page_whitelist(g_guard_pages, &g_guard_page_count);

    for (mod = (LDR_MODULE *) peb->LoaderData->InLoadOrderModuleList.Flink;
         mod->BaseAddress != NULL;
         mod = (LDR_MODULE *) mod->InLoadOrderModuleList.Flink) {

        exploit_set_guard_page(mod->BaseAddress);
    }
}

int exploit_set_guard_page(void *addr)
{
    MEMORY_BASIC_INFORMATION_CROSS mbi;

    addr = (void *)((uintptr_t) addr & ~0xfff);
    if(virtual_query(addr, &mbi) == FALSE ||
            (mbi.Protect & PAGE_READABLE) == 0) {
        return -1;
    }

    if(NT_SUCCESS(virtual_protect(
            addr, 0x1000, mbi.Protect | PAGE_GUARD)) == FALSE) {
        return -1;
    }
    return 0;
}

int WINAPI exploit_set_guard_page_wrapper(
    void *addr, uint32_t unused1, uint32_t unused2, uint32_t unused3)
{
    (void) unused1; (void) unused2; (void) unused3;
    return exploit_set_guard_page(addr);
}

int exploit_unset_guard_page(void *addr)
{
    MEMORY_BASIC_INFORMATION_CROSS mbi;

    addr = (void *)((uintptr_t) addr & ~0xfff);
    if(virtual_query(addr, &mbi) == FALSE ||
            (mbi.Protect & PAGE_READABLE) == 0) {
        return -1;
    }

    if(NT_SUCCESS(virtual_protect(
            addr, 0x1000, mbi.Protect & ~PAGE_GUARD)) == FALSE) {
        return -1;
    }
    return 0;
}

int WINAPI exploit_unset_guard_page_wrapper(
    void *addr, uint32_t unused1, uint32_t unused2, uint32_t unused3)
{
    (void) unused1; (void) unused2; (void) unused3;
    return exploit_unset_guard_page(addr);
}

void *exploit_get_last_guard_page()
{
    void *ret = array_get(
        &g_last_guard_page_addr_array, get_current_thread_id()
    );
    array_set(
        &g_last_guard_page_addr_array, get_current_thread_id(), NULL
    );
    return ret;
}

void exploit_set_last_guard_page(void *addr)
{
    array_set(
        &g_last_guard_page_addr_array, get_current_thread_id(), addr
    );
}

static int addr_in_stack(void *addr)
{
    NT_TIB *tib = (NT_TIB *) readtls(TLS_TEB);
    return addr >= tib->StackLimit && addr < tib->StackBase;
}

// Currently we just check if the memory block is of MEM_PRIVATE type.
// There are some APIs for traversing the heap, but they might miss
// some of the heap blocks (e.g., regions allocated through VirtualAlloc).
static int addr_in_heap(void *addr)
{
    MEMORY_BASIC_INFORMATION_CROSS mbi;
    virtual_query(addr, &mbi);
    return mbi.Type == MEM_PRIVATE;
}

int exploit_is_stack_pivoted()
{
    void *ptr = NULL;
    return addr_in_stack(&ptr) == 0;
}

int exploit_makes_stack_executable(
    HANDLE process_handle, PVOID addr, DWORD new_protection)
{
    return (new_protection & PAGE_EXECUTABLE) != 0 &&
        addr_in_stack(addr) != FALSE &&
        process_handle == get_current_process();
}

int exploit_makes_heap_executable(
    HANDLE process_handle, PVOID addr, DWORD new_protection)
{
    return (new_protection & PAGE_EXECUTABLE) != 0 &&
        addr_in_heap(addr) != FALSE &&
        process_handle == get_current_process();
}

static funcoff_t _LdrGetProcedureAddressEx[] = {
    {0x4ce7ba58, 0x302b8, 0},
    {0, 0, 0},
};

static funcoff_t _LdrFindResource_U[] = {
    {0x4ce7ba58, 0x41f53, 0},
    {0, 0, 0},
};

static funcoff_t _LdrLoadDll[] = {
    {0x4ce7ba58, 0x3c4b5, 0},
    {0, 0, 0},
};

static funcoff_t _RtlImageNtHeader[] = {
    {0x4ce7ba58, 0x3317f, 0},
    {0, 0, 0},
};

static funcoff_t _RtlPcToFileHeader[] = {
    {0x4ce7ba58, 0x400ff, 0},
    {0, 0, 0},
};

static mod2funcoff_t _ntdll[] = {
    {"LdrGetProcedureAddressEx", _LdrGetProcedureAddressEx},
    {"LdrFindResource_U", _LdrFindResource_U},
    {"LdrLoadDll", _LdrLoadDll},
    {"RtlImageNtHeader", _RtlImageNtHeader},
    {"RtlPcToFileHeader", _RtlPcToFileHeader},
    {NULL, NULL},
};

void find_guard_page_whitelist(uintptr_t *addresses, uint32_t *count)
{
    uint8_t *modaddr = (uint8_t *) GetModuleHandle("ntdll");
    for (mod2funcoff_t *p = _ntdll; p->funcname != NULL; p++) {
        uint8_t *ret = module_addr_timestamp(modaddr, 0, p->funcoff, NULL);
        if(ret != NULL) {
            addresses[*count] = (uintptr_t) ret;
            *count += 1;
        }
    }

    if(*count == 0) {
        log_action("gatherer");
    }
}

int exploit_is_guard_page_referer_whitelisted(
    uintptr_t *addrs, uint32_t count)
{
    // If we were unable to determine the Guard Page whitelist this means that
    // we can't use the feature on this OS yet, as it would generate a lot of
    // false positives (for legitimate calls to GetProcAddress etc).
    if(g_guard_page_count == 0) {
        return 0;
    }

    for (uint32_t idx = 0; idx < count; idx++) {
        for (uint32_t jdx = 0; jdx < g_guard_page_count; jdx++) {
            if(g_guard_pages[jdx] == addrs[idx]) {
                return 0;
            }
        }
    }
    return -1;
}

int exploit_hotpatch_guard_page_referer(uintptr_t memaddr, uintptr_t pc)
{
    uint8_t *insn = (uint8_t *) pc;

    hook_t *h = slab_getmem(&g_guard_page_referer_slab);

    (void) memaddr;

    if(memcmp(insn, "\x66\x39\x06", 3) == 0) {
        h->insn_signature = HOOK_INSN(ESI);
    }
    else {
        char buf[80];
        hexdump(buf, insn, 32);
        pipe(
            "INFO:Unknown instruction sequence for guard page "
            "referer hotpatching.. 0x%x => %z", pc, buf
        );
        return -1;
    }

    h->type = HOOK_TYPE_GUARD;
    h->addr = insn;
    h->library = "__guard__";
    return hook(h, NULL);
}
