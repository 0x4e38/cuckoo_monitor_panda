#include <windows.h>
#include <winnt.h>
#include <stdint.h>
#include <stdlib.h>
#include "exploit_detection.h"
#include "native.h"
#include "pipe.h"
#include "misc.h"
#include "symbol.h"

BOOL stackPivotDetection()
{
	BOOL ret = FALSE;
	PVOID esp = getStackPointer(); 
	
	ret = !isAddressInStack(esp);
	return ret;
}

void getStackBoundaries(PVOID *sb, PVOID *sl)
{
	NT_TIB *tib = NULL;
	tib = get_tib();
	*sb = tib->StackBase;
	*sl = tib->StackLimit;
}

BOOL isAddressInStack(PVOID addr)
{
	BOOL ret = FALSE;
	PVOID pStackBase = NULL, pStackLimit = NULL;
	
	getStackBoundaries(&pStackBase, &pStackLimit);
	ret = (addr <= pStackBase && addr >= pStackLimit);
	return ret;
}

// Currently we just check if the memory block is of MEM_PRIVATE type.
// There are some APIs for traversing the heap, but they might miss
// some of the heap blocks (VirtualAllocBlocks for example).
BOOL isAddressInHeap(PVOID addr)
{
	BOOL ret = FALSE;
	MEMORY_BASIC_INFORMATION_CROSS mbi;
	virtual_query(addr, &mbi);
	ret = (mbi.Type == MEM_PRIVATE);
	return ret;
}

BOOL stackDEPBypass(HANDLE hProcess, PVOID addr, DWORD new_protection)
{
	BOOL ret = FALSE;
	if (((new_protection & EXECUTE_PROTECTIONS) != 0) && 
	isAddressInStack(addr) &&
	(hProcess == get_current_process())) {
		return TRUE;
	}
	return ret;
}

BOOL heapDEPBypass(HANDLE hProcess, PVOID addr, DWORD new_protection)
{
	BOOL ret = FALSE;
	if (((new_protection & PAGE_EXECUTE_READWRITE) != 0) &&
	isAddressInHeap(addr) &&
	(hProcess == get_current_process())) {
		ret = TRUE;
	}
	return ret;
}
